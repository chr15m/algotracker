["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","promesa/core.cljc","~:line",25,"~:column",5,"~:end-line",25,"~:end-column",17],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$clojure.core","~$cljs.core","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",["~$map","~$delay","~$mapcat","~$await","~$let","~$future","~$spread","~$promise","~$run!","~$recur","~$loop"]],"~:macros",["^ ","~$do!",["^ ","~:arglists",["~#list",[["~$&","~$exprs"]]],"~:doc","Execute potentially side effectful code and return a promise resolved\n  to the last expression. Always awaiting the result of each\n  expression.","^4",405,"^5",1,"^3","promesa/core.cljc","~:name","~$promesa.core/do!","~:ns","~$promesa.core","~:macro",true],"^H",["^ ","^Q",["^R",[["~$bindings","~$&","~$body"]]],"^T","A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.","^4",419,"^5",1,"^3","promesa/core.cljc","^U","~$promesa.core/let","^W","^X","^Y",true],"^I",["^ ","^Q",["^R",[["~$&","^["]]],"^T","Analogous to `clojure.core/future` that returns a promise instance\n  instead of the `Future`. Usefull for execute synchronous code in a\n  separate thread (also works in cljs).","^4",439,"^5",1,"^3","promesa/core.cljc","^U","~$promesa.core/future","^W","^X","^Y",true],"~$plet",["^ ","^Q",["^R",[["^Z","~$&","^["]]],"^T","A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.","^4",429,"^5",1,"^3","promesa/core.cljc","^U","~$promesa.core/plet","^W","^X","^Y",true],"^M",["^ ","^Q",["^R",[["~$&","~$args"]]],"^4",482,"^5",1,"^3","promesa/core.cljc","^U","~$promesa.core/recur","^W","^X","^Y",true],"^N",["^ ","^Q",["^R",[["^Z","~$&","^["]]],"^4",451,"^5",1,"^3","promesa/core.cljc","^U","~$promesa.core/loop","^W","^X","^Y",true]],"^U","^X","~:reader-aliases",["^ "],"~:imports",null,"~:requires",["^ ","~$impl","~$promesa.impl","~$promesa.protocols","^1<","^>","^>","~$pt","^1<","~$goog","^1>","~$exec","~$promesa.exec","^1@","^1@","^=","^>","^1;","^1;","~$c","^>"],"~:seen",["^C",["~:require","~:require-macros"]],"~:shadow/js-access-global",["^C",["Error"]],"~:uses",null,"~:defs",["^ ","~$timeout",["^ ","~:protocol-inline",null,"^2",["^ ","^3","promesa/core.cljc","^4",380,"^5",7,"^6",380,"^7",14,"^Q",["^R",["~$quote",["^R",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","~$scheduler"]]]]],"^T","Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",4,"~:max-fixed-arity",4,"~:method-params",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1J"]],"^Q",["^R",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1J"]]],"~:arglists-meta",["^R",[null,null,null]]]],"^U","~$promesa.core/timeout","^3","promesa/core.cljc","^7",14,"^1K",["^ ","^1L",false,"^1M",4,"^1N",4,"^1O",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1J"]],"^Q",["^R",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1J"]]],"^1P",["^R",[null,null,null]]],"^1O",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1J"]],"~:protocol-impl",null,"^1M",4,"^1P",["^R",[null,null,null]],"^5",1,"^1L",false,"~:methods",[["^ ","^1M",2,"^1L",false,"~:tag","~$any"],["^ ","^1M",3,"^1L",false,"^1T","^1U"],["^ ","^1M",4,"^1L",false,"^1T","^1U"]],"^4",380,"^6",380,"^1N",4,"~:fn-var",true,"^Q",["^R",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1J"]]],"^T","Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError"],"~$deferred?",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",97,"^5",7,"^6",97,"^7",16,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return true if `v` is a promise instance (alias to `promise?`."],"^U","~$promesa.core/deferred?","^3","promesa/core.cljc","^7",16,"^1O",["^R",[["~$v"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",97,"~:ret-tag","~$boolean","^6",97,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return true if `v` is a promise instance (alias to `promise?`."],"^D",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",175,"^5",7,"^6",175,"^7",10,"^Q",["^R",["^1I",["^R",[["~$f","~$p"],["~$executor","~$f","~$p"]]]]],"^T","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$f","~$p"],["^1[","~$f","~$p"]],"^Q",["^R",[["~$f","~$p"],["^1[","~$f","~$p"]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/map","^3","promesa/core.cljc","^7",10,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$f","~$p"],["^1[","~$f","~$p"]],"^Q",["^R",[["~$f","~$p"],["^1[","~$f","~$p"]]],"^1P",["^R",[null,null]]],"^1O",[["~$f","~$p"],["^1[","~$f","~$p"]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",175,"^6",175,"^1N",3,"^1V",true,"^Q",["^R",[["~$f","~$p"],["^1[","~$f","~$p"]]],"^T","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`."],"^E",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",394,"^5",7,"^6",394,"^7",12,"^Q",["^R",["^1I",["^R",[["~$t"],["~$t","~$v"],["~$t","~$v","^1J"]]]]],"^T","Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$t"],["~$t","~$v"],["~$t","~$v","^1J"]],"^Q",["^R",[["~$t"],["~$t","~$v"],["~$t","~$v","^1J"]]],"^1P",["^R",[null,null,null]]]],"^U","~$promesa.core/delay","^3","promesa/core.cljc","^7",12,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$t"],["~$t","~$v"],["~$t","~$v","^1J"]],"^Q",["^R",[["~$t"],["~$t","~$v"],["~$t","~$v","^1J"]]],"^1P",["^R",[null,null,null]]],"^1O",[["~$t"],["~$t","~$v"],["~$t","~$v","^1J"]],"^1R",null,"^1M",3,"^1P",["^R",[null,null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",1,"^1L",false,"^1T","^1U"],["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","~$promesa.impl/*default-promise*"]],"^4",394,"^6",394,"^1N",3,"^1V",true,"^Q",["^R",[["~$t"],["~$t","~$v"],["~$t","~$v","^1J"]]],"^T","Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached."],"~$resolved?",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",111,"^5",7,"^6",111,"^7",16,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Returns true if promise `p` is already fulfilled."],"^U","~$promesa.core/resolved?","^3","promesa/core.cljc","^7",16,"^1O",["^R",[["~$p"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",111,"^1Y","^1U","^6",111,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Returns true if promise `p` is already fulfilled."],"^F",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",184,"^5",7,"^6",184,"^7",13,"^Q",["^R",["^1I",["^R",[["~$f","~$p"],["^1[","~$f","~$p"]]]]],"^T","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$f","~$p"],["^1[","~$f","~$p"]],"^Q",["^R",[["~$f","~$p"],["^1[","~$f","~$p"]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/mapcat","^3","promesa/core.cljc","^7",13,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$f","~$p"],["^1[","~$f","~$p"]],"^Q",["^R",[["~$f","~$p"],["^1[","~$f","~$p"]]],"^1P",["^R",[null,null]]],"^1O",[["~$f","~$p"],["^1[","~$f","~$p"]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",184,"^6",184,"^1N",3,"^1V",true,"^Q",["^R",[["~$f","~$p"],["^1[","~$f","~$p"]]],"^T","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`."],"~$cancelled?",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",339,"^5",7,"^6",339,"^7",17,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return true if `v` is a cancelled promise."],"^U","~$promesa.core/cancelled?","^3","promesa/core.cljc","^7",17,"^1O",["^R",[["~$v"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",339,"^1Y","^1U","^6",339,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return true if `v` is a cancelled promise."],"~$bind",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",157,"^5",7,"^6",157,"^7",11,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]]]],"^T","A convenient alias for `then`.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/bind","^3","promesa/core.cljc","^7",11,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",157,"^6",157,"^1N",3,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^T","A convenient alias for `then`."],"~$resolve!",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",346,"^5",7,"^6",346,"^7",15,"^Q",["^R",["^1I",["^R",[["~$o"],["~$o","~$v"]]]]],"^T","Resolve a completable promise with a value.","^1K",["^ ","^1L",false,"^1M",2,"^1N",2,"^1O",[["~$o"],["~$o","~$v"]],"^Q",["^R",[["~$o"],["~$o","~$v"]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/resolve!","^3","promesa/core.cljc","^7",15,"^1K",["^ ","^1L",false,"^1M",2,"^1N",2,"^1O",[["~$o"],["~$o","~$v"]],"^Q",["^R",[["~$o"],["~$o","~$v"]]],"^1P",["^R",[null,null]]],"^1O",[["~$o"],["~$o","~$v"]],"^1R",null,"^1M",2,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",1,"^1L",false,"^1T","^1U"],["^ ","^1M",2,"^1L",false,"^1T","^1U"]],"^4",346,"^6",346,"^1N",2,"^1V",true,"^Q",["^R",[["~$o"],["~$o","~$v"]]],"^T","Resolve a completable promise with a value."],"^1U",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",294,"^5",7,"^6",294,"^7",10,"^Q",["^R",["^1I",["^R",[["~$promises"],["^2<","~$default"]]]]],"^T","Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.","^1K",["^ ","^1L",false,"^1M",2,"^1N",2,"^1O",[["^2<"],["^2<","^2="]],"^Q",["^R",[["^2<"],["^2<","^2="]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/any","^3","promesa/core.cljc","^7",10,"^1K",["^ ","^1L",false,"^1M",2,"^1N",2,"^1O",[["^2<"],["^2<","^2="]],"^Q",["^R",[["^2<"],["^2<","^2="]]],"^1P",["^R",[null,null]]],"^1O",[["^2<"],["^2<","^2="]],"^1R",null,"^1M",2,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",1,"^1L",false,"^1T","^1U"],["^ ","^1M",2,"^1L",false,"^1T","^22"]],"^4",294,"^6",294,"^1N",2,"^1V",true,"^Q",["^R",[["^2<"],["^2<","^2="]]],"^T","Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled."],"~$finally",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",216,"^5",7,"^6",216,"^7",14,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]]]],"^T","Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/finally","^3","promesa/core.cljc","^7",14,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",216,"^6",216,"^1N",3,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^T","Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored."],"~$then'",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",164,"^5",7,"^6",164,"^7",12,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]]]],"^T","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/then'","^3","promesa/core.cljc","^7",12,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",164,"^6",164,"^1N",3,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^T","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result."],"~$chain'",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",203,"^5",7,"^6",203,"^7",13,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","~$f","~$&","~$fs"]]]]],"^T","Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`).","^1K",["^ ","^1L",true,"^1M",2,"^1N",2,"^1O",[["~$p","~$f"]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","~$&","^2D"]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/chain'","^3","promesa/core.cljc","^7",13,"^1K",["^ ","^1L",true,"^1M",2,"^1N",2,"^1O",[["~$p","~$f"]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","~$&","^2D"]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"]],"^1R",null,"^1M",2,"^1P",["^R",[null,null]],"^5",1,"^1L",true,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",2,"^1L",true,"^1T",["^C",[null,"^1U"]]]],"^4",203,"^6",203,"^1N",2,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","~$f","~$&","^2D"]]],"^T","Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`)."],"~$wrap",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",137,"^5",7,"^6",137,"^7",11,"^Q",["^R",["^1I",["^R",[["~$v"]]]]]],"^U","~$promesa.core/wrap","^3","promesa/core.cljc","^7",11,"^1O",["^R",[["~$v"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",137,"^1Y",["^C",[null,"^1U"]],"^6",137,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$v"]]]]]],"~$promisify",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",358,"^5",7,"^6",358,"^7",16,"^Q",["^R",["^1I",["^R",[["~$callable"]]]]],"^T","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"^U","~$promesa.core/promisify","^3","promesa/core.cljc","^7",16,"^1O",["^R",[["^2I"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",358,"^1Y","~$function","^6",358,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["^2I"]]]]],"^T","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"~$rejected",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",48,"^5",7,"^6",48,"^7",15,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return a rejected promise with provided reason."],"^U","~$promesa.core/rejected","^3","promesa/core.cljc","^7",15,"^1O",["^R",[["~$v"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",48,"^1Y","^1U","^6",48,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return a rejected promise with provided reason."],"^K",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",58,"^5",7,"^6",58,"^7",14,"^Q",["^R",["^1I",["^R",[["~$v"],["~$v","^1["]]]]],"^T","The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.","^1K",["^ ","^1L",false,"^1M",2,"^1N",2,"^1O",[["~$v"],["~$v","^1["]],"^Q",["^R",[["~$v"],["~$v","^1["]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/promise","^3","promesa/core.cljc","^7",14,"^1K",["^ ","^1L",false,"^1M",2,"^1N",2,"^1O",[["~$v"],["~$v","^1["]],"^Q",["^R",[["~$v"],["~$v","^1["]]],"^1P",["^R",[null,null]]],"^1O",[["~$v"],["~$v","^1["]],"^1R",null,"^1M",2,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",1,"^1L",false,"^1T","^1U"],["^ ","^1M",2,"^1L",false,"^1T","^1U"]],"^4",58,"^6",58,"^1N",2,"^1V",true,"^Q",["^R",[["~$v"],["~$v","^1["]]],"^T","The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise."],"~$create",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",68,"^5",7,"^6",68,"^7",13,"^Q",["^R",["^1I",["^R",[["~$f"],["~$f","^1["]]]]],"^T","Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.","^1K",["^ ","^1L",false,"^1M",2,"^1N",2,"^1O",[["~$f"],["~$f","^1["]],"^Q",["^R",[["~$f"],["~$f","^1["]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/create","^3","promesa/core.cljc","^7",13,"^1K",["^ ","^1L",false,"^1M",2,"^1N",2,"^1O",[["~$f"],["~$f","^1["]],"^Q",["^R",[["~$f"],["~$f","^1["]]],"^1P",["^R",[null,null]]],"^1O",[["~$f"],["~$f","^1["]],"^1R",null,"^1M",2,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",1,"^1L",false,"^1T","^22"],["^ ","^1M",2,"^1L",false,"^1T","^22"]],"^4",68,"^6",68,"^1N",2,"^1V",true,"^Q",["^R",[["~$f"],["~$f","^1["]]],"^T","Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`."],"~$race",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",288,"^5",7,"^6",288,"^7",11,"^Q",["^R",["^1I",["^R",[["^2<"]]]]]],"^U","~$promesa.core/race","^3","promesa/core.cljc","^7",11,"^1O",["^R",[["^2<"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",288,"^1Y","^1U","^6",288,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["^2<"]]]]]],"~$cancel!",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",333,"^5",7,"^6",333,"^7",14,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Cancel the promise."],"^U","~$promesa.core/cancel!","^3","promesa/core.cljc","^7",14,"^1O",["^R",[["~$p"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",333,"^6",333,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Cancel the promise."],"~$thenable?",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",104,"^5",10,"^6",104,"^7",19,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Returns true if `v` is a promise like object."],"^U","~$promesa.core/thenable?","^3","promesa/core.cljc","^7",19,"^1O",["^R",[["~$v"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",4,"^1L",false,"^4",104,"^1Y","^1Z","^6",104,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Returns true if `v` is a promise like object."],"~$TimeoutException",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",373,"^5",6,"^6",373,"^7",22,"~:jsdoc",["@constructor"],"^Q",["^R",["^1I",["^R",[["~$message"]]]]]],"^U","~$promesa.core/TimeoutException","^3","promesa/core.cljc","^7",22,"^1O",["^R",[["^2Y"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",4,"^1L",false,"^4",372,"^1Y","^1U","^6",373,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["^2Y"]]]]],"^2X",["@constructor"]],"~$done?",["^ ","^2",["^ ","^3","promesa/core.cljc","^4",131,"^5",6,"^6",131,"^7",11],"^U","~$promesa.core/done?","^3","promesa/core.cljc","^7",11,"^5",1,"^4",131,"^6",131,"^1T","^2K","^T","Returns true if promise `p` is already done."],"~$err",["^ ","^U","~$promesa.core/err","^3","promesa/core.cljc","^4",258,"^5",1,"^6",258,"^7",9,"^2",["^ ","^3","promesa/core.cljc","^4",258,"^5",6,"^6",258,"^7",9],"^T","A short alias for `error` function."],"~$catch'",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",239,"^5",7,"^6",239,"^7",13,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","~$pred-or-type","~$f"]]]]],"^T","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","^34","~$f"]],"^Q",["^R",[["~$p","~$f"],["~$p","^34","~$f"]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/catch'","^3","promesa/core.cljc","^7",13,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","^34","~$f"]],"^Q",["^R",[["~$p","~$f"],["~$p","^34","~$f"]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"],["~$p","^34","~$f"]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",239,"^6",239,"^1N",3,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","^34","~$f"]]],"^T","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler."],"^L",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",326,"^5",7,"^6",326,"^7",11,"^Q",["^R",["^1I",["^R",[["~$f","~$coll"],["~$f","^36","^1["]]]]],"^T","A promise aware run! function.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$f","^36"],["~$f","^36","^1["]],"^Q",["^R",[["~$f","^36"],["~$f","^36","^1["]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/run!","^3","promesa/core.cljc","^7",11,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$f","^36"],["~$f","^36","^1["]],"^Q",["^R",[["~$f","^36"],["~$f","^36","^1["]]],"^1P",["^R",[null,null]]],"^1O",[["~$f","^36"],["~$f","^36","^1["]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T",["^C",[null,"^1U"]]]],"^4",326,"^6",326,"^1N",3,"^1V",true,"^Q",["^R",[["~$f","^36"],["~$f","^36","^1["]]],"^T","A promise aware run! function."],"~$all",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",262,"^5",7,"^6",262,"^7",10,"^Q",["^R",["^1I",["^R",[["^2<"]]]]],"^T","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"^U","~$promesa.core/all","^3","promesa/core.cljc","^7",10,"^1O",["^R",[["^2<"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",262,"^1Y","^1U","^6",262,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["^2<"]]]]],"^T","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"~$reject!",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",351,"^5",7,"^6",351,"^7",14,"^Q",["^R",["^1I",["^R",[["~$p","~$e"]]]]],"^T","Reject a completable promise with an error."],"^U","~$promesa.core/reject!","^3","promesa/core.cljc","^7",14,"^1O",["^R",[["~$p","~$e"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",351,"^1Y","^1U","^6",351,"^1N",2,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$p","~$e"]]]]],"^T","Reject a completable promise with an error."],"~$promise?",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",91,"^5",7,"^6",91,"^7",15,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return true if `v` is a promise instance."],"^U","~$promesa.core/promise?","^3","promesa/core.cljc","^7",15,"^1O",["^R",[["~$v"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",91,"^1Y","^1Z","^6",91,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return true if `v` is a promise instance."],"~$resolved",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",43,"^5",7,"^6",43,"^7",15,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return a resolved promise with provided value."],"^U","~$promesa.core/resolved","^3","promesa/core.cljc","^7",15,"^1O",["^R",[["~$v"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",43,"^1Y","^1U","^6",43,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$v"]]]]],"^T","Return a resolved promise with provided value."],"~$deferred",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",53,"^5",7,"^6",53,"^7",15,"^Q",["^R",["^1I",["^R",[[]]]]],"^T","Creates an empty promise instance."],"^U","~$promesa.core/deferred","^3","promesa/core.cljc","^7",15,"^1O",["^R",[[]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",53,"^1Y","^22","^6",53,"^1N",0,"^1V",true,"^Q",["^R",["^1I",["^R",[[]]]]],"^T","Creates an empty promise instance."],"~$*loop-run-fn*",["^ ","^2",["^ ","^3","promesa/core.cljc","^4",449,"^5",16,"^6",449,"^7",29,"~:dynamic",true],"^U","~$promesa.core/*loop-run-fn*","^3","promesa/core.cljc","^7",29,"^5",1,"^3C",true,"^4",449,"^6",449,"^1T","^1U"],"~$catch",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",225,"^5",7,"^6",225,"^7",12,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","^34","~$f"]]]]],"^T","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","^34","~$f"]],"^Q",["^R",[["~$p","~$f"],["~$p","^34","~$f"]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/catch","^3","promesa/core.cljc","^7",12,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","^34","~$f"]],"^Q",["^R",[["~$p","~$f"],["~$p","^34","~$f"]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"],["~$p","^34","~$f"]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",225,"^6",225,"^1N",3,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","^34","~$f"]]],"^T","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler."],"~$chain",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",196,"^5",7,"^6",196,"^7",12,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","~$f","~$&","^2D"]]]]],"^T","Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.","^1K",["^ ","^1L",true,"^1M",2,"^1N",2,"^1O",[["~$p","~$f"]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","~$&","^2D"]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/chain","^3","promesa/core.cljc","^7",12,"^1K",["^ ","^1L",true,"^1M",2,"^1N",2,"^1O",[["~$p","~$f"]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","~$&","^2D"]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"]],"^1R",null,"^1M",2,"^1P",["^R",[null,null]],"^5",1,"^1L",true,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",2,"^1L",true,"^1T",["^C",[null,"^1U"]]]],"^4",196,"^6",196,"^1N",2,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","~$f","~$&","^2D"]]],"^T","Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions."],"~$handle",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",210,"^5",7,"^6",210,"^7",13,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]]]],"^T","Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/handle","^3","promesa/core.cljc","^7",13,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",210,"^6",210,"^1N",3,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^T","Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function."],"~$rejected?",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",116,"^5",7,"^6",116,"^7",16,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Returns true if promise `p` is already rejected."],"^U","~$promesa.core/rejected?","^3","promesa/core.cljc","^7",16,"^1O",["^R",[["~$p"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",116,"^1Y","^1U","^6",116,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Returns true if promise `p` is already rejected."],"~$then",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",143,"^5",7,"^6",143,"^7",11,"^Q",["^R",["^1I",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]]]],"^T","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/then","^3","promesa/core.cljc","^7",11,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^1P",["^R",[null,null]]],"^1O",[["~$p","~$f"],["~$p","~$f","^1["]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",143,"^6",143,"^1N",3,"^1V",true,"^Q",["^R",[["~$p","~$f"],["~$p","~$f","^1["]]],"^T","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped."],"~$extract",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",126,"^5",7,"^6",126,"^7",14,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Returns the current promise value."],"^U","~$promesa.core/extract","^3","promesa/core.cljc","^7",14,"^1O",["^R",[["~$p"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",126,"^1Y","^1U","^6",126,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Returns the current promise value."],"~$error",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",253,"^5",7,"^6",253,"^7",12,"^Q",["^R",["^1I",["^R",[["~$f","~$p"],["~$f","~$type","~$p"]]]]],"^T","Same as `catch` but with parameters inverted.","^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$f","~$p"],["~$f","^3R","~$p"]],"^Q",["^R",[["~$f","~$p"],["~$f","^3R","~$p"]]],"^1P",["^R",[null,null]]]],"^U","~$promesa.core/error","^3","promesa/core.cljc","^7",12,"^1K",["^ ","^1L",false,"^1M",3,"^1N",3,"^1O",[["~$f","~$p"],["~$f","^3R","~$p"]],"^Q",["^R",[["~$f","~$p"],["~$f","^3R","~$p"]]],"^1P",["^R",[null,null]]],"^1O",[["~$f","~$p"],["~$f","^3R","~$p"]],"^1R",null,"^1M",3,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^1S",[["^ ","^1M",2,"^1L",false,"^1T","^1U"],["^ ","^1M",3,"^1L",false,"^1T","^1U"]],"^4",253,"^6",253,"^1N",3,"^1V",true,"^Q",["^R",[["~$f","~$p"],["~$f","^3R","~$p"]]],"^T","Same as `catch` but with parameters inverted."],"~$pending?",["^ ","^1H",null,"^2",["^ ","^3","promesa/core.cljc","^4",121,"^5",7,"^6",121,"^7",15,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Returns true if promise `p` is stil pending."],"^U","~$promesa.core/pending?","^3","promesa/core.cljc","^7",15,"^1O",["^R",[["~$p"]]],"^1R",null,"^1P",["^R",[null,null]],"^5",1,"^1L",false,"^4",121,"^1Y","^1U","^6",121,"^1N",1,"^1V",true,"^Q",["^R",["^1I",["^R",[["~$p"]]]]],"^T","Returns true if promise `p` is stil pending."]],"^1C",["^ ","^X","^X","^>","^>","^=","^>","~$c","^>"],"~:cljs.analyzer/constants",["^ ","^1A",["^C",["~:promesa.core/default","~:else","~:resolved","~:counter","~:rejections"]],"~:order",["^3W","^3Y","^3Z","^3[","^3X"]],"~:flags",["^ ","^1B",["^C",[]],"^1C",["^C",[]]],"~:js-deps",["^ "],"~:deps",["^1>","^>","^1<","^>","^1@","^1;"]]