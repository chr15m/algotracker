["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","promesa/core$macros.cljc","~:line",25,"~:column",5,"~:end-line",25,"~:end-column",17],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$clojure.core","~$cljs.core","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",["~$map","~$delay","~$mapcat","~$await","~$let","~$future","~$spread","~$promise","~$run!","~$recur","~$loop"]],"~:name","~$promesa.core$macros","~:reader-aliases",["^ "],"~:imports",null,"~:requires",["^ ","~$impl","~$promesa.impl","~$promesa.protocols","^V","^>","^>","~$pt","^V","~$goog","^X","~$exec","~$promesa.exec","^Z","^Z","^=","^>","^U","^U","~$c","^>"],"~:seen",["^C",["~:require","~:require-macros"]],"~:shadow/js-access-global",["^C",["Error"]],"~:uses",null,"~:defs",["^ ","~$do!",["^ ","~:protocol-inline",null,"^2",["^ ","^3","promesa/core$macros.cljc","^7",14,"~:top-fn",["^ ","~:variadic?",true,"~:fixed-arity",0,"~:max-fixed-arity",0,"~:method-params",["~#list",[["^1<",["~$exprs"]]]],"~:arglists",["^1<",[["~$&","^1="]]],"~:arglists-meta",["^1<",[null]]],"^5",11,"^4",405,"~:macro",true,"^6",405,"^1>",["^1<",["~$quote",["^1<",[["~$&","^1="]]]]],"~:doc","Execute potentially side effectful code and return a promise resolved\n  to the last expression. Always awaiting the result of each\n  expression."],"^O","~$promesa.core$macros/do!","^3","promesa/core$macros.cljc","^7",14,"^17",["^ ","^18",true,"^19",0,"^1:",0,"^1;",["^1<",[["^1<",["^1="]]]],"^1>",["^1<",[["~$&","^1="]]],"^1?",["^1<",[null]]],"^1;",["^1<",[["^1<",["^1="]]]],"~:protocol-impl",null,"^19",0,"^1?",["^1<",[null]],"^5",1,"^18",true,"~:methods",[["^ ","^19",0,"^18",true,"~:tag",["^C",["~$seq","~$cljs.core/IList"]]]],"^4",405,"^1@",true,"~:ret-tag","~$any","^6",405,"^1:",0,"~:fn-var",false,"^1>",["^1<",[["~$&","^1="]]],"^1B","Execute potentially side effectful code and return a promise resolved\n  to the last expression. Always awaiting the result of each\n  expression."],"~$timeout",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",380,"^5",7,"^6",380,"^7",14,"^1>",["^1<",["^1A",["^1<",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","~$scheduler"]]]]],"^1B","Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError","^17",["^ ","^18",false,"^19",4,"^1:",4,"^1;",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1M"]],"^1>",["^1<",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1M"]]],"^1?",["^1<",[null,null,null]]]],"^O","~$promesa.core$macros/timeout","^3","promesa/core$macros.cljc","^7",14,"^17",["^ ","^18",false,"^19",4,"^1:",4,"^1;",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1M"]],"^1>",["^1<",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1M"]]],"^1?",["^1<",[null,null,null]]],"^1;",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1M"]],"^1D",null,"^19",4,"^1?",["^1<",[null,null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"],["^ ","^19",4,"^18",false,"^1F","^1J"]],"^4",380,"^6",380,"^1:",4,"^1K",true,"^1>",["^1<",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^1M"]]],"^1B","Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError"],"~$deferred?",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",97,"^5",7,"^6",97,"^7",16,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return true if `v` is a promise instance (alias to `promise?`."],"^O","~$promesa.core$macros/deferred?","^3","promesa/core$macros.cljc","^7",16,"^1;",["^1<",[["~$v"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",97,"^1I","~$boolean","^6",97,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return true if `v` is a promise instance (alias to `promise?`."],"^D",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",175,"^5",7,"^6",175,"^7",10,"^1>",["^1<",["^1A",["^1<",[["~$f","~$p"],["~$executor","~$f","~$p"]]]]],"^1B","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$f","~$p"],["^1R","~$f","~$p"]],"^1>",["^1<",[["~$f","~$p"],["^1R","~$f","~$p"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/map","^3","promesa/core$macros.cljc","^7",10,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$f","~$p"],["^1R","~$f","~$p"]],"^1>",["^1<",[["~$f","~$p"],["^1R","~$f","~$p"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$f","~$p"],["^1R","~$f","~$p"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",175,"^6",175,"^1:",3,"^1K",true,"^1>",["^1<",[["~$f","~$p"],["^1R","~$f","~$p"]]],"^1B","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`."],"^E",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",394,"^5",7,"^6",394,"^7",12,"^1>",["^1<",["^1A",["^1<",[["~$t"],["~$t","~$v"],["~$t","~$v","^1M"]]]]],"^1B","Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$t"],["~$t","~$v"],["~$t","~$v","^1M"]],"^1>",["^1<",[["~$t"],["~$t","~$v"],["~$t","~$v","^1M"]]],"^1?",["^1<",[null,null,null]]]],"^O","~$promesa.core$macros/delay","^3","promesa/core$macros.cljc","^7",12,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$t"],["~$t","~$v"],["~$t","~$v","^1M"]],"^1>",["^1<",[["~$t"],["~$t","~$v"],["~$t","~$v","^1M"]]],"^1?",["^1<",[null,null,null]]],"^1;",[["~$t"],["~$t","~$v"],["~$t","~$v","^1M"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",1,"^18",false,"^1F","^1J"],["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","~$promesa.impl/*default-promise*"]],"^4",394,"^6",394,"^1:",3,"^1K",true,"^1>",["^1<",[["~$t"],["~$t","~$v"],["~$t","~$v","^1M"]]],"^1B","Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached."],"~$resolved?",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",111,"^5",7,"^6",111,"^7",16,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Returns true if promise `p` is already fulfilled."],"^O","~$promesa.core$macros/resolved?","^3","promesa/core$macros.cljc","^7",16,"^1;",["^1<",[["~$p"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",111,"^1I","^1J","^6",111,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Returns true if promise `p` is already fulfilled."],"^F",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",184,"^5",7,"^6",184,"^7",13,"^1>",["^1<",["^1A",["^1<",[["~$f","~$p"],["^1R","~$f","~$p"]]]]],"^1B","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$f","~$p"],["^1R","~$f","~$p"]],"^1>",["^1<",[["~$f","~$p"],["^1R","~$f","~$p"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/mapcat","^3","promesa/core$macros.cljc","^7",13,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$f","~$p"],["^1R","~$f","~$p"]],"^1>",["^1<",[["~$f","~$p"],["^1R","~$f","~$p"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$f","~$p"],["^1R","~$f","~$p"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",184,"^6",184,"^1:",3,"^1K",true,"^1>",["^1<",[["~$f","~$p"],["^1R","~$f","~$p"]]],"^1B","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`."],"~$cancelled?",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",339,"^5",7,"^6",339,"^7",17,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return true if `v` is a cancelled promise."],"^O","~$promesa.core$macros/cancelled?","^3","promesa/core$macros.cljc","^7",17,"^1;",["^1<",[["~$v"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",339,"^1I","^1J","^6",339,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return true if `v` is a cancelled promise."],"~$bind",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",157,"^5",7,"^6",157,"^7",11,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]]]],"^1B","A convenient alias for `then`.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/bind","^3","promesa/core$macros.cljc","^7",11,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",157,"^6",157,"^1:",3,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1B","A convenient alias for `then`."],"~$resolve!",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",346,"^5",7,"^6",346,"^7",15,"^1>",["^1<",["^1A",["^1<",[["~$o"],["~$o","~$v"]]]]],"^1B","Resolve a completable promise with a value.","^17",["^ ","^18",false,"^19",2,"^1:",2,"^1;",[["~$o"],["~$o","~$v"]],"^1>",["^1<",[["~$o"],["~$o","~$v"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/resolve!","^3","promesa/core$macros.cljc","^7",15,"^17",["^ ","^18",false,"^19",2,"^1:",2,"^1;",[["~$o"],["~$o","~$v"]],"^1>",["^1<",[["~$o"],["~$o","~$v"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$o"],["~$o","~$v"]],"^1D",null,"^19",2,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",1,"^18",false,"^1F","^1J"],["^ ","^19",2,"^18",false,"^1F","^1J"]],"^4",346,"^6",346,"^1:",2,"^1K",true,"^1>",["^1<",[["~$o"],["~$o","~$v"]]],"^1B","Resolve a completable promise with a value."],"^1J",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",294,"^5",7,"^6",294,"^7",10,"^1>",["^1<",["^1A",["^1<",[["~$promises"],["^23","~$default"]]]]],"^1B","Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.","^17",["^ ","^18",false,"^19",2,"^1:",2,"^1;",[["^23"],["^23","^24"]],"^1>",["^1<",[["^23"],["^23","^24"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/any","^3","promesa/core$macros.cljc","^7",10,"^17",["^ ","^18",false,"^19",2,"^1:",2,"^1;",[["^23"],["^23","^24"]],"^1>",["^1<",[["^23"],["^23","^24"]]],"^1?",["^1<",[null,null]]],"^1;",[["^23"],["^23","^24"]],"^1D",null,"^19",2,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",1,"^18",false,"^1F","^1J"],["^ ","^19",2,"^18",false,"^1F","^1U"]],"^4",294,"^6",294,"^1:",2,"^1K",true,"^1>",["^1<",[["^23"],["^23","^24"]]],"^1B","Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled."],"~$finally",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",216,"^5",7,"^6",216,"^7",14,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]]]],"^1B","Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/finally","^3","promesa/core$macros.cljc","^7",14,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",216,"^6",216,"^1:",3,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1B","Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored."],"~$then'",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",164,"^5",7,"^6",164,"^7",12,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]]]],"^1B","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/then'","^3","promesa/core$macros.cljc","^7",12,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",164,"^6",164,"^1:",3,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1B","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result."],"~$chain'",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",203,"^5",7,"^6",203,"^7",13,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","~$f","~$&","~$fs"]]]]],"^1B","Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`).","^17",["^ ","^18",true,"^19",2,"^1:",2,"^1;",[["~$p","~$f"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","~$&","^2;"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/chain'","^3","promesa/core$macros.cljc","^7",13,"^17",["^ ","^18",true,"^19",2,"^1:",2,"^1;",[["~$p","~$f"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","~$&","^2;"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"]],"^1D",null,"^19",2,"^1?",["^1<",[null,null]],"^5",1,"^18",true,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",2,"^18",true,"^1F",["^C",[null,"^1J"]]]],"^4",203,"^6",203,"^1:",2,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","~$&","^2;"]]],"^1B","Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`)."],"^H",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^7",14,"^17",["^ ","^18",true,"^19",1,"^1:",1,"^1;",["^1<",[["^1<",["~$bindings","~$body"]]]],"^1>",["^1<",[["^2=","~$&","^2>"]]],"^1?",["^1<",[null]]],"^5",11,"^4",419,"^1@",true,"^6",419,"^1>",["^1<",["^1A",["^1<",[["^2=","~$&","^2>"]]]]],"^1B","A `let` alternative that always returns promise and waits for all the\n  promises on the bindings."],"^O","~$promesa.core$macros/let","^3","promesa/core$macros.cljc","^7",14,"^17",["^ ","^18",true,"^19",1,"^1:",1,"^1;",["^1<",[["^1<",["^2=","^2>"]]]],"^1>",["^1<",[["^2=","~$&","^2>"]]],"^1?",["^1<",[null]]],"^1;",["^1<",[["^1<",["^2=","^2>"]]]],"^1D",null,"^19",1,"^1?",["^1<",[null]],"^5",1,"^18",true,"^1E",[["^ ","^19",1,"^18",true,"^1F",["^C",["^1G","^1H"]]]],"^4",419,"^1@",true,"^1I","^1J","^6",419,"^1:",1,"^1K",false,"^1>",["^1<",[["^2=","~$&","^2>"]]],"^1B","A `let` alternative that always returns promise and waits for all the\n  promises on the bindings."],"~$wrap",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",137,"^5",7,"^6",137,"^7",11,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]]],"^O","~$promesa.core$macros/wrap","^3","promesa/core$macros.cljc","^7",11,"^1;",["^1<",[["~$v"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",137,"^1I",["^C",[null,"^1J"]],"^6",137,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]]],"^I",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^7",17,"^17",["^ ","^18",true,"^19",0,"^1:",0,"^1;",["^1<",[["^1<",["^2>"]]]],"^1>",["^1<",[["~$&","^2>"]]],"^1?",["^1<",[null]]],"^5",11,"^4",439,"^1@",true,"^6",439,"^1>",["^1<",["^1A",["^1<",[["~$&","^2>"]]]]],"^1B","Analogous to `clojure.core/future` that returns a promise instance\n  instead of the `Future`. Usefull for execute synchronous code in a\n  separate thread (also works in cljs)."],"^O","~$promesa.core$macros/future","^3","promesa/core$macros.cljc","^7",17,"^17",["^ ","^18",true,"^19",0,"^1:",0,"^1;",["^1<",[["^1<",["^2>"]]]],"^1>",["^1<",[["~$&","^2>"]]],"^1?",["^1<",[null]]],"^1;",["^1<",[["^1<",["^2>"]]]],"^1D",null,"^19",0,"^1?",["^1<",[null]],"^5",1,"^18",true,"^1E",[["^ ","^19",0,"^18",true,"^1F",["^C",["^1G","^1H"]]]],"^4",439,"^1@",true,"^1I","^1J","^6",439,"^1:",0,"^1K",false,"^1>",["^1<",[["~$&","^2>"]]],"^1B","Analogous to `clojure.core/future` that returns a promise instance\n  instead of the `Future`. Usefull for execute synchronous code in a\n  separate thread (also works in cljs)."],"~$promisify",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",358,"^5",7,"^6",358,"^7",16,"^1>",["^1<",["^1A",["^1<",[["~$callable"]]]]],"^1B","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"^O","~$promesa.core$macros/promisify","^3","promesa/core$macros.cljc","^7",16,"^1;",["^1<",[["^2D"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",358,"^1I","~$function","^6",358,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["^2D"]]]]],"^1B","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"~$plet",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^7",15,"^17",["^ ","^18",true,"^19",1,"^1:",1,"^1;",["^1<",[["^1<",["^2=","^2>"]]]],"^1>",["^1<",[["^2=","~$&","^2>"]]],"^1?",["^1<",[null]]],"^5",11,"^4",429,"^1@",true,"^6",429,"^1>",["^1<",["^1A",["^1<",[["^2=","~$&","^2>"]]]]],"^1B","A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body."],"^O","~$promesa.core$macros/plet","^3","promesa/core$macros.cljc","^7",15,"^17",["^ ","^18",true,"^19",1,"^1:",1,"^1;",["^1<",[["^1<",["^2=","^2>"]]]],"^1>",["^1<",[["^2=","~$&","^2>"]]],"^1?",["^1<",[null]]],"^1;",["^1<",[["^1<",["^2=","^2>"]]]],"^1D",null,"^19",1,"^1?",["^1<",[null]],"^5",1,"^18",true,"^1E",[["^ ","^19",1,"^18",true,"^1F",["^C",["^1G","^1H"]]]],"^4",429,"^1@",true,"^1I","^1J","^6",429,"^1:",1,"^1K",false,"^1>",["^1<",[["^2=","~$&","^2>"]]],"^1B","A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body."],"~$rejected",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",48,"^5",7,"^6",48,"^7",15,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return a rejected promise with provided reason."],"^O","~$promesa.core$macros/rejected","^3","promesa/core$macros.cljc","^7",15,"^1;",["^1<",[["~$v"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",48,"^1I","^1J","^6",48,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return a rejected promise with provided reason."],"^K",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",58,"^5",7,"^6",58,"^7",14,"^1>",["^1<",["^1A",["^1<",[["~$v"],["~$v","^1R"]]]]],"^1B","The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.","^17",["^ ","^18",false,"^19",2,"^1:",2,"^1;",[["~$v"],["~$v","^1R"]],"^1>",["^1<",[["~$v"],["~$v","^1R"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/promise","^3","promesa/core$macros.cljc","^7",14,"^17",["^ ","^18",false,"^19",2,"^1:",2,"^1;",[["~$v"],["~$v","^1R"]],"^1>",["^1<",[["~$v"],["~$v","^1R"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$v"],["~$v","^1R"]],"^1D",null,"^19",2,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",1,"^18",false,"^1F","^1J"],["^ ","^19",2,"^18",false,"^1F","^1J"]],"^4",58,"^6",58,"^1:",2,"^1K",true,"^1>",["^1<",[["~$v"],["~$v","^1R"]]],"^1B","The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise."],"~$create",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",68,"^5",7,"^6",68,"^7",13,"^1>",["^1<",["^1A",["^1<",[["~$f"],["~$f","^1R"]]]]],"^1B","Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.","^17",["^ ","^18",false,"^19",2,"^1:",2,"^1;",[["~$f"],["~$f","^1R"]],"^1>",["^1<",[["~$f"],["~$f","^1R"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/create","^3","promesa/core$macros.cljc","^7",13,"^17",["^ ","^18",false,"^19",2,"^1:",2,"^1;",[["~$f"],["~$f","^1R"]],"^1>",["^1<",[["~$f"],["~$f","^1R"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$f"],["~$f","^1R"]],"^1D",null,"^19",2,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",1,"^18",false,"^1F","^1U"],["^ ","^19",2,"^18",false,"^1F","^1U"]],"^4",68,"^6",68,"^1:",2,"^1K",true,"^1>",["^1<",[["~$f"],["~$f","^1R"]]],"^1B","Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`."],"~$race",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",288,"^5",7,"^6",288,"^7",11,"^1>",["^1<",["^1A",["^1<",[["^23"]]]]]],"^O","~$promesa.core$macros/race","^3","promesa/core$macros.cljc","^7",11,"^1;",["^1<",[["^23"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",288,"^1I","^1J","^6",288,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["^23"]]]]]],"~$cancel!",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",333,"^5",7,"^6",333,"^7",14,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Cancel the promise."],"^O","~$promesa.core$macros/cancel!","^3","promesa/core$macros.cljc","^7",14,"^1;",["^1<",[["~$p"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",333,"^6",333,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Cancel the promise."],"~$thenable?",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",104,"^5",10,"^6",104,"^7",19,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Returns true if `v` is a promise like object."],"^O","~$promesa.core$macros/thenable?","^3","promesa/core$macros.cljc","^7",19,"^1;",["^1<",[["~$v"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",4,"^18",false,"^4",104,"^1I","^1Q","^6",104,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Returns true if `v` is a promise like object."],"~$TimeoutException",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",373,"^5",6,"^6",373,"^7",22,"~:jsdoc",["@constructor"],"^1>",["^1<",["^1A",["^1<",[["~$message"]]]]]],"^O","~$promesa.core$macros/TimeoutException","^3","promesa/core$macros.cljc","^7",22,"^1;",["^1<",[["^2V"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",4,"^18",false,"^4",372,"^1I","^1J","^6",373,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["^2V"]]]]],"^2U",["@constructor"]],"~$done?",["^ ","^2",["^ ","^3","promesa/core$macros.cljc","^4",131,"^5",6,"^6",131,"^7",11],"^O","~$promesa.core$macros/done?","^3","promesa/core$macros.cljc","^7",11,"^5",1,"^4",131,"^6",131,"^1F","^2F","^1B","Returns true if promise `p` is already done."],"~$err",["^ ","^O","~$promesa.core$macros/err","^3","promesa/core$macros.cljc","^4",258,"^5",1,"^6",258,"^7",9,"^2",["^ ","^3","promesa/core$macros.cljc","^4",258,"^5",6,"^6",258,"^7",9],"^1B","A short alias for `error` function."],"~$catch'",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",239,"^5",7,"^6",239,"^7",13,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","~$pred-or-type","~$f"]]]]],"^1B","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","^31","~$f"]],"^1>",["^1<",[["~$p","~$f"],["~$p","^31","~$f"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/catch'","^3","promesa/core$macros.cljc","^7",13,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","^31","~$f"]],"^1>",["^1<",[["~$p","~$f"],["~$p","^31","~$f"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"],["~$p","^31","~$f"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",239,"^6",239,"^1:",3,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","^31","~$f"]]],"^1B","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler."],"^L",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",326,"^5",7,"^6",326,"^7",11,"^1>",["^1<",["^1A",["^1<",[["~$f","~$coll"],["~$f","^33","^1R"]]]]],"^1B","A promise aware run! function.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$f","^33"],["~$f","^33","^1R"]],"^1>",["^1<",[["~$f","^33"],["~$f","^33","^1R"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/run!","^3","promesa/core$macros.cljc","^7",11,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$f","^33"],["~$f","^33","^1R"]],"^1>",["^1<",[["~$f","^33"],["~$f","^33","^1R"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$f","^33"],["~$f","^33","^1R"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F",["^C",[null,"^1J"]]]],"^4",326,"^6",326,"^1:",3,"^1K",true,"^1>",["^1<",[["~$f","^33"],["~$f","^33","^1R"]]],"^1B","A promise aware run! function."],"^M",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",482,"^5",11,"^6",482,"^7",16,"^1@",true,"^1>",["^1<",["^1A",["^1<",[["~$&","~$args"]]]]],"^17",["^ ","^18",true,"^19",0,"^1:",0,"^1;",["^1<",[["^1<",["^35"]]]],"^1>",["^1<",[["~$&","^35"]]],"^1?",["^1<",[null]]]],"^O","~$promesa.core$macros/recur","^3","promesa/core$macros.cljc","^7",16,"^17",["^ ","^18",true,"^19",0,"^1:",0,"^1;",["^1<",[["^1<",["^35"]]]],"^1>",["^1<",[["~$&","^35"]]],"^1?",["^1<",[null]]],"^1;",["^1<",[["^1<",["^35"]]]],"^1D",null,"^19",0,"^1?",["^1<",[null]],"^5",1,"^18",true,"^1E",[["^ ","^19",0,"^18",true,"^1F",["^C",["^1G","^1H"]]]],"^4",482,"^1@",true,"^1I","^1J","^6",482,"^1:",0,"^1K",false,"^1>",["^1<",[["~$&","^35"]]]],"~$all",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",262,"^5",7,"^6",262,"^7",10,"^1>",["^1<",["^1A",["^1<",[["^23"]]]]],"^1B","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"^O","~$promesa.core$macros/all","^3","promesa/core$macros.cljc","^7",10,"^1;",["^1<",[["^23"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",262,"^1I","^1J","^6",262,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["^23"]]]]],"^1B","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"~$reject!",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",351,"^5",7,"^6",351,"^7",14,"^1>",["^1<",["^1A",["^1<",[["~$p","~$e"]]]]],"^1B","Reject a completable promise with an error."],"^O","~$promesa.core$macros/reject!","^3","promesa/core$macros.cljc","^7",14,"^1;",["^1<",[["~$p","~$e"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",351,"^1I","^1J","^6",351,"^1:",2,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$p","~$e"]]]]],"^1B","Reject a completable promise with an error."],"~$promise?",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",91,"^5",7,"^6",91,"^7",15,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return true if `v` is a promise instance."],"^O","~$promesa.core$macros/promise?","^3","promesa/core$macros.cljc","^7",15,"^1;",["^1<",[["~$v"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",91,"^1I","^1Q","^6",91,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return true if `v` is a promise instance."],"^N",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",451,"^5",11,"^6",451,"^7",15,"^1@",true,"^1>",["^1<",["^1A",["^1<",[["^2=","~$&","^2>"]]]]],"^17",["^ ","^18",true,"^19",1,"^1:",1,"^1;",["^1<",[["^1<",["^2=","^2>"]]]],"^1>",["^1<",[["^2=","~$&","^2>"]]],"^1?",["^1<",[null]]]],"^O","~$promesa.core$macros/loop","^3","promesa/core$macros.cljc","^7",15,"^17",["^ ","^18",true,"^19",1,"^1:",1,"^1;",["^1<",[["^1<",["^2=","^2>"]]]],"^1>",["^1<",[["^2=","~$&","^2>"]]],"^1?",["^1<",[null]]],"^1;",["^1<",[["^1<",["^2=","^2>"]]]],"^1D",null,"^19",1,"^1?",["^1<",[null]],"^5",1,"^18",true,"^1E",[["^ ","^19",1,"^18",true,"^1F",["^C",["^1G","^1H"]]]],"^4",451,"^1@",true,"^1I","^1J","^6",451,"^1:",1,"^1K",false,"^1>",["^1<",[["^2=","~$&","^2>"]]]],"~$resolved",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",43,"^5",7,"^6",43,"^7",15,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return a resolved promise with provided value."],"^O","~$promesa.core$macros/resolved","^3","promesa/core$macros.cljc","^7",15,"^1;",["^1<",[["~$v"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",43,"^1I","^1J","^6",43,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$v"]]]]],"^1B","Return a resolved promise with provided value."],"~$deferred",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",53,"^5",7,"^6",53,"^7",15,"^1>",["^1<",["^1A",["^1<",[[]]]]],"^1B","Creates an empty promise instance."],"^O","~$promesa.core$macros/deferred","^3","promesa/core$macros.cljc","^7",15,"^1;",["^1<",[[]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",53,"^1I","^1U","^6",53,"^1:",0,"^1K",true,"^1>",["^1<",["^1A",["^1<",[[]]]]],"^1B","Creates an empty promise instance."],"~$*loop-run-fn*",["^ ","^2",["^ ","^3","promesa/core$macros.cljc","^4",449,"^5",16,"^6",449,"^7",29,"~:dynamic",true],"^O","~$promesa.core$macros/*loop-run-fn*","^3","promesa/core$macros.cljc","^7",29,"^5",1,"^3C",true,"^4",449,"^6",449,"^1F","^1J"],"~$catch",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",225,"^5",7,"^6",225,"^7",12,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","^31","~$f"]]]]],"^1B","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","^31","~$f"]],"^1>",["^1<",[["~$p","~$f"],["~$p","^31","~$f"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/catch","^3","promesa/core$macros.cljc","^7",12,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","^31","~$f"]],"^1>",["^1<",[["~$p","~$f"],["~$p","^31","~$f"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"],["~$p","^31","~$f"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",225,"^6",225,"^1:",3,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","^31","~$f"]]],"^1B","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler."],"~$chain",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",196,"^5",7,"^6",196,"^7",12,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","~$f","~$&","^2;"]]]]],"^1B","Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.","^17",["^ ","^18",true,"^19",2,"^1:",2,"^1;",[["~$p","~$f"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","~$&","^2;"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/chain","^3","promesa/core$macros.cljc","^7",12,"^17",["^ ","^18",true,"^19",2,"^1:",2,"^1;",[["~$p","~$f"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","~$&","^2;"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"]],"^1D",null,"^19",2,"^1?",["^1<",[null,null]],"^5",1,"^18",true,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",2,"^18",true,"^1F",["^C",[null,"^1J"]]]],"^4",196,"^6",196,"^1:",2,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","~$&","^2;"]]],"^1B","Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions."],"~$handle",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",210,"^5",7,"^6",210,"^7",13,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]]]],"^1B","Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/handle","^3","promesa/core$macros.cljc","^7",13,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",210,"^6",210,"^1:",3,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1B","Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function."],"~$rejected?",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",116,"^5",7,"^6",116,"^7",16,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Returns true if promise `p` is already rejected."],"^O","~$promesa.core$macros/rejected?","^3","promesa/core$macros.cljc","^7",16,"^1;",["^1<",[["~$p"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",116,"^1I","^1J","^6",116,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Returns true if promise `p` is already rejected."],"~$then",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",143,"^5",7,"^6",143,"^7",11,"^1>",["^1<",["^1A",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]]]],"^1B","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/then","^3","promesa/core$macros.cljc","^7",11,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$p","~$f"],["~$p","~$f","^1R"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",143,"^6",143,"^1:",3,"^1K",true,"^1>",["^1<",[["~$p","~$f"],["~$p","~$f","^1R"]]],"^1B","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped."],"~$extract",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",126,"^5",7,"^6",126,"^7",14,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Returns the current promise value."],"^O","~$promesa.core$macros/extract","^3","promesa/core$macros.cljc","^7",14,"^1;",["^1<",[["~$p"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",126,"^1I","^1J","^6",126,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Returns the current promise value."],"~$error",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",253,"^5",7,"^6",253,"^7",12,"^1>",["^1<",["^1A",["^1<",[["~$f","~$p"],["~$f","~$type","~$p"]]]]],"^1B","Same as `catch` but with parameters inverted.","^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$f","~$p"],["~$f","^3R","~$p"]],"^1>",["^1<",[["~$f","~$p"],["~$f","^3R","~$p"]]],"^1?",["^1<",[null,null]]]],"^O","~$promesa.core$macros/error","^3","promesa/core$macros.cljc","^7",12,"^17",["^ ","^18",false,"^19",3,"^1:",3,"^1;",[["~$f","~$p"],["~$f","^3R","~$p"]],"^1>",["^1<",[["~$f","~$p"],["~$f","^3R","~$p"]]],"^1?",["^1<",[null,null]]],"^1;",[["~$f","~$p"],["~$f","^3R","~$p"]],"^1D",null,"^19",3,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^1E",[["^ ","^19",2,"^18",false,"^1F","^1J"],["^ ","^19",3,"^18",false,"^1F","^1J"]],"^4",253,"^6",253,"^1:",3,"^1K",true,"^1>",["^1<",[["~$f","~$p"],["~$f","^3R","~$p"]]],"^1B","Same as `catch` but with parameters inverted."],"~$pending?",["^ ","^16",null,"^2",["^ ","^3","promesa/core$macros.cljc","^4",121,"^5",7,"^6",121,"^7",15,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Returns true if promise `p` is stil pending."],"^O","~$promesa.core$macros/pending?","^3","promesa/core$macros.cljc","^7",15,"^1;",["^1<",[["~$p"]]],"^1D",null,"^1?",["^1<",[null,null]],"^5",1,"^18",false,"^4",121,"^1I","^1J","^6",121,"^1:",1,"^1K",true,"^1>",["^1<",["^1A",["^1<",[["~$p"]]]]],"^1B","Returns true if promise `p` is stil pending."]],"^11",["^ ","~$promesa.core","^3V","^>","^>","^=","^>","~$c","^>"],"~:cljs.analyzer/constants",["^ ","^[",["^C",["~:args","~$promesa.core/resolve!","~$res__15191__auto__","~$params__15190__auto__","~:promesa.core/default","~$cljs.core/=","~$___15113__auto__","~$cljs.core/array-map","~:else","~$cljs.core/->","~$cljs.core/identity","~$promesa.protocols/-promise","~$promesa.core/do!","~$___15149__auto__","~$promesa.exec/submit!","~:type","~$___15167__auto__","~$do","~$___15114__auto__","~$promesa.core/deferred","~$err__15192__auto__","~$cljs.core/map?","~$f__15174__auto__","~:resolved","~$promesa.core/all","~$cljs.core/let","~:counter","~$cljs.core/cond","~$promesa.core/handle","~$cljs.core/nil?","~:promesa.core/recur","~$cljs.core/fn","~$promesa.core/then","~$cljs.core/not","~:rejections","~$cljs.core/and","~$promesa.protocols/-bind","~$promesa.core/*loop-run-fn*","~$promesa.core/reject!"]],"~:order",["^40","^4C","^4F","^4N","^44","^4P","^4K","^4>","^47","^42","^49","^48","^4<","^45","^4D","^4L","^4:","^4E","^4B","^46","^4Q","^4?","^3[","^4H","^3Z","^4@","^4G","^4M","^4I","^4R","^4O","^4A","^41","^4;","^4J","^4=","^3X","^3Y","^43"]],"~:flags",["^ ","^10",["^C",[]],"^11",["^C",[]]],"~:js-deps",["^ "],"~:deps",["^X","^>","^V","^>","^Z","^U"]]